---
description: Rules for preventing code duplication in the UCAN project
globs: "**/*.py"
alwaysApply: true
---

Before creating any new class, method, or file in the UCAN project, follow these rules to prevent code duplication:

### Pre-Creation Check
- Before creating a new class, method, or file, first search the codebase for similar functionality
- Use semantic search to find components with similar names or purposes
- Analyze existing code to understand established patterns before implementing new ones

```python
# AVOID THIS: Creating a new class without checking for existing similar functionality
class NewMessageHandler:
    """Handles messages in a conversation."""
    # ...

# INSTEAD: First search for similar classes (e.g., "message", "handler", "conversation")
# If a similar class exists, extend or adapt it rather than creating a new one
```

### Reuse Existing Components
- Prefer extending existing classes over creating new ones
- Use composition over inheritance when adding new functionality
- Look for utility functions and helper methods before implementing your own

```python
# AVOID THIS: Creating a new utility function
def format_timestamp(timestamp: str) -> str:
    """Format a timestamp for display."""
    # ...

# INSTEAD: Check if similar utilities exist in ucan/core/utils.py or related modules
```

### Naming Conventions Check
- Analyze the naming conventions used in the module you're modifying
- Ensure new elements follow the same naming patterns as existing ones
- Be consistent with abbreviations and terminology

```python
# If existing code uses:
open_conversation()
save_conversation()
delete_conversation()

# THEN use consistent naming for new methods:
export_conversation()  # NOT: conversation_export() or export_conv()
```

### Module Boundaries
- Respect the established module boundaries defined in the architecture
- Place new code in the appropriate module based on its responsibility
- Don't create new modules without clear justification for why existing ones are insufficient

### Code Reuse Checklist
Before implementing a new feature, answer these questions:
1. Does a similar feature already exist in the codebase?
2. Can existing components be extended to support this feature?
3. Are there utility functions that can be reused?
4. Does this feature belong in an existing module?
5. Does the implementation follow established patterns?

### Refactoring Opportunity
- When finding similar but not identical functionality, consider refactoring to create a shared abstraction
- Extract common logic into shared utility functions
- Create base classes for related components

```python
# AVOID THIS: Having two similar methods
def save_conversation_as_json(conversation, path):
    # Implementation for JSON

def save_conversation_as_txt(conversation, path):
    # Implementation for TXT

# INSTEAD: Refactor to use a common base with specific formats
def save_conversation(conversation, path, format="json"):
    if format == "json":
        # JSON implementation
    elif format == "txt":
        # TXT implementation
    else:
        raise ValueError(f"Unsupported format: {format}")
``` 