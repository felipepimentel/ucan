---
description: Rules for managing changes in the UCAN project
globs: "**/*"
alwaysApply: true
---

When planning, implementing, or reviewing changes to the codebase, follow these rules:

### Change Planning Process
Before modifying the codebase, follow these steps:

1. **Understand the Context**
   - Read the relevant documentation
   - Analyze the affected modules and their interactions
   - Identify stakeholders and dependencies

2. **Evaluate Impact**
   - Assess which components will be affected
   - Consider backwards compatibility
   - Estimate complexity and scope

3. **Plan the Approach**
   - Decide whether to modify existing code or create new components
   - Break down the change into logical steps
   - Consider how to test the changes

### Implementation Checklist
When implementing changes, use this checklist:

- [ ] Search for existing solutions in the codebase
- [ ] Check component registries for reusable parts
- [ ] Follow established patterns and naming conventions
- [ ] Update documentation and registries
- [ ] Add appropriate tests
- [ ] Review for consistency with existing code

### Change Size Guidelines
- **Small Changes**: Limited to a single file or component, minimal risk
- **Medium Changes**: Affects multiple related components, moderate risk
- **Large Changes**: Affects multiple modules or core functionality, high risk

For larger changes, break them down into smaller, manageable increments that can be tested and validated independently.

### Implementation Strategies

#### Extension Strategy
Prefer extending existing functionality when:
- The new feature is a natural evolution of an existing one
- The core logic remains the same with minor variations
- The change maintains backward compatibility

```python
# GOOD: Extending existing functionality
class EnhancedConversation(Conversation):
    """Extends Conversation with additional capabilities."""
    
    def export_to_pdf(self, path: Path) -> None:
        """Export the conversation to PDF format."""
        # Implementation
```

#### Composition Strategy
Prefer composition when:
- The new feature combines multiple existing features
- The change would make existing classes too complex
- You need to reuse functionality across different contexts

```python
# GOOD: Composition of existing functionality
class ConversationExporter:
    """Handles exporting conversations in various formats."""
    
    def __init__(self, conversation: Conversation) -> None:
        self.conversation = conversation
    
    def export(self, path: Path, format: str) -> None:
        """Export the conversation in the specified format."""
        # Implementation using the conversation object
```

#### Refactoring Strategy
Consider refactoring when:
- Multiple similar implementations exist
- The code has become difficult to maintain
- New requirements make the current design inadequate

```python
# BEFORE REFACTORING: Duplicate logic
def save_json(data, path):
    # JSON saving logic
    
def save_config(config, path):
    # Similar JSON saving logic

# AFTER REFACTORING: Unified approach
def save_data(data, path, pretty_print=False):
    # Generic data saving logic
```

### Documentation Updates
All changes must include appropriate documentation updates:

1. Update docstrings for modified code
2. Update component registries with new or changed components
3. Update README.md or other documentation files as needed
4. Add examples for new functionality

### Change Validation
Before considering a change complete, validate it against these criteria:

1. Code follows established style and architecture patterns
2. Tests cover the new functionality
3. No duplication with existing code
4. Documentation is complete and accurate
5. Component registries are updated 